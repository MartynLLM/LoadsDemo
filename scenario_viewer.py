#!/usr/bin/env python3
"""
Scenario Summary Viewer
Interactive tkinter application for visualizing load correlation vs chemistry correlation
from the scenario_summary view generated by cq_dual_generator.py
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import numpy as np
import os

class ScenarioSummaryViewer:
    def __init__(self, root):
        self.root = root
        self.root.title("Scenario Summary Viewer - Load vs Chemistry Correlation")
        self.root.geometry("1200x800")
        
        # Data storage
        self.df = None
        self.db_path = None
        
        # Plot variables
        self.factors = [
            'flow_mean_percentage',
            'flow_variance_percentage', 
            'chem_mean_percentage',
            'chem_variance_percentage',
            'flow_correlation'
        ]
        
        self.factor_labels = {
            'flow_mean_percentage': 'Flow Mean %',
            'flow_variance_percentage': 'Flow Variance %',
            'chem_mean_percentage': 'Chemistry Mean %',
            'chem_variance_percentage': 'Chemistry Variance %',
            'flow_correlation': 'Flow Correlation'
        }
        
        self.setup_ui()
        
    def setup_ui(self):
        """Setup the user interface."""
        # Create main frames
        control_frame = ttk.Frame(self.root)
        control_frame.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)
        
        plot_frame = ttk.Frame(self.root)
        plot_frame.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Database selection
        db_frame = ttk.LabelFrame(control_frame, text="Database Selection")
        db_frame.pack(fill=tk.X, pady=(0,10))
        
        ttk.Button(db_frame, text="Select Database", 
                  command=self.select_database).pack(side=tk.LEFT, padx=5, pady=5)
        
        self.db_label = ttk.Label(db_frame, text="No database selected")
        self.db_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        ttk.Button(db_frame, text="Load Data", 
                  command=self.load_data).pack(side=tk.RIGHT, padx=5, pady=5)
        
        # Factor selection frame
        factor_frame = ttk.LabelFrame(control_frame, text="Factor Selection")
        factor_frame.pack(fill=tk.X, pady=(0,10))
        
        # Instructions
        instructions = ttk.Label(factor_frame, 
                               text="Select values for 4 factors. The 5th factor will be used as series variable.")
        instructions.pack(pady=5)
        
        # Create factor selection widgets
        self.factor_vars = {}
        self.factor_combos = {}
        self.factor_checkboxes = {}
        
        factors_grid = ttk.Frame(factor_frame)
        factors_grid.pack(pady=5)
        
        for i, factor in enumerate(self.factors):
            row = i // 3
            col = i % 3
            
            factor_sub_frame = ttk.Frame(factors_grid)
            factor_sub_frame.grid(row=row, column=col, padx=10, pady=5, sticky='w')
            
            # Checkbox to enable/disable factor
            self.factor_vars[factor] = tk.BooleanVar(value=True)
            cb = ttk.Checkbutton(factor_sub_frame, 
                               text=self.factor_labels[factor],
                               variable=self.factor_vars[factor],
                               command=self.update_factor_selection)
            cb.pack(anchor='w')
            self.factor_checkboxes[factor] = cb
            
            # Combobox for value selection
            combo = ttk.Combobox(factor_sub_frame, width=15, state='readonly')
            combo.pack(anchor='w', pady=(2,0))
            self.factor_combos[factor] = combo
        
        # Plot controls
        plot_control_frame = ttk.LabelFrame(control_frame, text="Plot Controls")
        plot_control_frame.pack(fill=tk.X, pady=(0,10))
        
        controls_grid = ttk.Frame(plot_control_frame)
        controls_grid.pack(pady=5)
        
        ttk.Button(controls_grid, text="Generate Plot", 
                  command=self.generate_plot).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(controls_grid, text="Clear Plot", 
                  command=self.clear_plot).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(controls_grid, text="Save Plot", 
                  command=self.save_plot).pack(side=tk.LEFT, padx=5)
        
        # Data info
        self.data_info_label = ttk.Label(controls_grid, text="No data loaded")
        self.data_info_label.pack(side=tk.RIGHT, padx=5)
        
        # Setup matplotlib figure
        self.setup_plot(plot_frame)
        
        # Initialize factor selection
        self.update_factor_selection()
        
    def setup_plot(self, parent):
        """Setup matplotlib figure and canvas."""
        self.fig, self.ax = plt.subplots(figsize=(10, 6))
        self.ax.set_xlabel('Chemistry Correlation')
        self.ax.set_ylabel('Load Correlation')
        self.ax.set_title('Load Correlation vs Chemistry Correlation')
        self.ax.grid(True, alpha=0.3)
        
        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.fig, parent)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
        
        # Add navigation toolbar
        toolbar = NavigationToolbar2Tk(self.canvas, parent)
        toolbar.update()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        
    def select_database(self):
        """Select database file."""
        db_path = filedialog.askopenfilename(
            title="Select Database File",
            filetypes=[("SQLite files", "*.db"), ("All files", "*.*")]
        )
        
        if db_path:
            self.db_path = db_path
            self.db_label.config(text=f"Selected: {os.path.basename(db_path)}")
            
    def load_data(self):
        """Load data from selected database."""
        if not self.db_path:
            messagebox.showerror("Error", "Please select a database file first.")
            return
            
        try:
            # Connect to database and load scenario_summary view
            conn = sqlite3.connect(self.db_path)
            
            # Check if scenario_summary view exists
            cursor = conn.cursor()
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='view' AND name='scenario_summary'
            """)
            
            if not cursor.fetchone():
                messagebox.showerror("Error", 
                    "scenario_summary view not found in database. "
                    "Please ensure you're using a database generated by cq_dual_generator.py")
                conn.close()
                return
            
            # Load data
            query = """
                SELECT scenario_id, flow_combination_id, chem_combination_id,
                       flow_mean_percentage, flow_variance_percentage, flow_correlation,
                       chem_mean_percentage, chem_variance_percentage, chem_correlation,
                       load_correlation, rmse, r_squared, n_points
                FROM scenario_summary
                ORDER BY flow_mean_percentage, flow_variance_percentage, flow_correlation,
                         chem_mean_percentage, chem_variance_percentage, chem_correlation
            """
            
            self.df = pd.read_sql_query(query, conn)
            conn.close()
            
            # Update UI with loaded data
            self.populate_factor_values()
            self.data_info_label.config(
                text=f"Loaded {len(self.df)} scenarios from {len(self.df['scenario_id'].unique())} scenarios"
            )
            
            messagebox.showinfo("Success", f"Loaded {len(self.df)} records from database.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load data: {str(e)}")
            
    def populate_factor_values(self):
        """Populate comboboxes with unique values from loaded data."""
        if self.df is None:
            return
            
        for factor in self.factors:
            unique_values = sorted(self.df[factor].unique())
            self.factor_combos[factor]['values'] = unique_values
            if unique_values:
                self.factor_combos[factor].set(unique_values[0])
                
    def update_factor_selection(self):
        """Update factor selection to ensure exactly 4 are selected."""
        selected_count = sum(var.get() for var in self.factor_vars.values())
        
        # If more than 4 selected, disable the rest
        if selected_count >= 4:
            for factor, var in self.factor_vars.items():
                if not var.get():
                    self.factor_checkboxes[factor].config(state='disabled')
        else:
            # Re-enable all checkboxes
            for factor in self.factors:
                self.factor_checkboxes[factor].config(state='normal')
        
        # Update combobox states
        for factor, var in self.factor_vars.items():
            state = 'readonly' if var.get() else 'disabled'
            self.factor_combos[factor].config(state=state)
            
    def generate_plot(self):
        """Generate the correlation plot."""
        if self.df is None:
            messagebox.showerror("Error", "Please load data first.")
            return
            
        # Validate selection
        selected_factors = [f for f in self.factors if self.factor_vars[f].get()]
        if len(selected_factors) != 4:
            messagebox.showerror("Error", "Please select exactly 4 factors.")
            return
            
        # Find the series factor (unselected)
        series_factor = None
        for factor in self.factors:
            if not self.factor_vars[factor].get():
                series_factor = factor
                break
                
        if not series_factor:
            messagebox.showerror("Error", "Please leave exactly 1 factor unselected for series.")
            return
            
        try:
            self.plot_correlation_data(selected_factors, series_factor)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate plot: {str(e)}")
            
    def plot_correlation_data(self, selected_factors, series_factor):
        """Plot the correlation data."""
        # Clear previous plot
        self.ax.clear()
        
        # Build filter conditions
        filter_conditions = []
        filter_values = {}
        
        for factor in selected_factors:
            value = self.factor_combos[factor].get()
            if value:
                try:
                    # Convert to appropriate type
                    if factor.endswith('_percentage'):
                        value = int(value)
                    else:
                        value = float(value)
                    filter_conditions.append(f"{factor} == @value_{factor}")
                    filter_values[f"value_{factor}"] = value
                except ValueError:
                    messagebox.showerror("Error", f"Invalid value for {factor}: {value}")
                    return
        
        # Apply filters
        if filter_conditions:
            filter_query = " & ".join(filter_conditions)
            filtered_df = self.df.query(filter_query, local_dict=filter_values)
        else:
            filtered_df = self.df.copy()
            
        if filtered_df.empty:
            messagebox.showwarning("Warning", "No data matches the selected criteria.")
            return
            
        # Get unique values for series factor
        series_values = sorted(filtered_df[series_factor].unique())
        
        # Color map for series
        colors = plt.cm.tab10(np.linspace(0, 1, len(series_values)))
        
        # Plot each series
        for i, series_value in enumerate(series_values):
            series_data = filtered_df[filtered_df[series_factor] == series_value]
            
            if not series_data.empty:
                self.ax.scatter(
                    series_data['chem_correlation'],
                    series_data['load_correlation'],
                    c=[colors[i]],
                    label=f"{self.factor_labels[series_factor]}: {series_value}",
                    alpha=0.7,
                    s=50
                )
        
        # Customize plot
        self.ax.set_xlabel('Chemistry Correlation')
        self.ax.set_ylabel('Load Correlation') 
        
        # Create title with filter information
        title_parts = []
        for factor in selected_factors:
            value = filter_values.get(f"value_{factor}", "")
            title_parts.append(f"{self.factor_labels[factor]}: {value}")
        
        title = "Load vs Chemistry Correlation\n" + ", ".join(title_parts)
        self.ax.set_title(title, fontsize=10)
        
        # Add legend
        if len(series_values) <= 15:  # Only show legend if not too many series
            self.ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        
        # Add grid and diagonal reference line
        self.ax.grid(True, alpha=0.3)
        
        # Add y=x reference line
        xlim = self.ax.get_xlim()
        ylim = self.ax.get_ylim()
        ref_min = max(min(xlim), min(ylim))
        ref_max = min(max(xlim), max(ylim))
        self.ax.plot([ref_min, ref_max], [ref_min, ref_max], 
                    'k--', alpha=0.5, label='y=x reference')
        
        # Set equal aspect ratio for better comparison
        self.ax.set_aspect('equal', adjustable='box')
        
        # Update layout and redraw
        self.fig.tight_layout()
        self.canvas.draw()
        
        # Update info label
        self.data_info_label.config(
            text=f"Plotted {len(filtered_df)} points in {len(series_values)} series"
        )
        
    def clear_plot(self):
        """Clear the current plot and reset factor selection."""
        self.ax.clear()
        self.ax.set_xlabel('Chemistry Correlation')
        self.ax.set_ylabel('Load Correlation')
        self.ax.set_title('Load Correlation vs Chemistry Correlation')
        self.ax.grid(True, alpha=0.3)
        self.canvas.draw()
        
        # Reset factor selection - enable all checkboxes
        for factor in self.factors:
            self.factor_checkboxes[factor].config(state='normal')
            self.factor_combos[factor].config(state='readonly')
        
        # Reset data info label
        if self.df is not None:
            self.data_info_label.config(
                text=f"Loaded {len(self.df)} scenarios - ready for new plot"
            )
        
    def save_plot(self):
        """Save the current plot to file."""
        if not hasattr(self.ax, 'collections') or not self.ax.collections:
            messagebox.showwarning("Warning", "No plot to save.")
            return
            
        filename = filedialog.asksaveasfilename(
            defaultextension=".png",
            filetypes=[
                ("PNG files", "*.png"),
                ("PDF files", "*.pdf"),
                ("SVG files", "*.svg"),
                ("All files", "*.*")
            ]
        )
        
        if filename:
            try:
                self.fig.savefig(filename, dpi=300, bbox_inches='tight')
                messagebox.showinfo("Success", f"Plot saved to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save plot: {str(e)}")


def main():
    """Main function to run the application."""
    root = tk.Tk()
    app = ScenarioSummaryViewer(root)
    
    # Set up proper window closing
    def on_closing():
        plt.close('all')
        root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Check if database file provided as command line argument
    import sys
    if len(sys.argv) > 1:
        db_path = sys.argv[1]
        if os.path.exists(db_path):
            app.db_path = db_path
            app.db_label.config(text=f"Selected: {os.path.basename(db_path)}")
    
    root.mainloop()


if __name__ == "__main__":
    main()